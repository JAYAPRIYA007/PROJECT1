# sigmoid.output<-function(x)
# {
# return  ( 1.0/ (1.0  +exp(-x)))
# }
# 
# sigmoid.derivative<-function(x)
# {
#   return ( x * (1-x))
# }
# 




#========================================================
#Neuron class with methods creation.....
Neuron<-setClass(
  
  "Neuron",
  slots = c(
    inputs="vector",
    weights="vector",
    error="numeric",
    biasWeight="numeric",
    output="numeric"
  ),
  prototype=list(
    inputs = c(),
    weights= c(),
    error=0,
    biasWeight=0,
    output=0
  )
  
  # myOutput=function(object)
  # {
  #    sum <- 0
  #    inplen<-length(inputs)
  #   for (i in 1 :inplen)
  #   {
  #     sum = sum + (weights[i] * inputs[i])
  #   }
  #    sigsum<-sigmoid.output(sum)
  #   object@output= sigsum
  #   return (sigsum)
  # }
)
# create a method to assign the value of the location
# setGeneric(name="setOutput",
#            def=function(theObject,output)
#            {
#              standardGeneric("setOutput")
#            }
# )
# 
# setMethod(f="setOutput",
#           signature="Neuron",
#           definition=function(theObject,output)
#           {
#             theObject@output <- output
#             validObject(theObject)
#             return(theObject)
#           }
# )
# create a method to get the value of the location
setGeneric(name="myOutput",
           def=function(theObject)
           {
             standardGeneric("myOutput")
           }
)

setMethod(f="myOutput",
          signature="Neuron",
          definition=function(theObject)
          {
            total<-0.0
            inplen<-length(theObject@inputs)
         #   print('inplen')
          #  print(inplen)
            prevtotal<-0
            for (i in 1 :inplen)
            {
           #   print('Wt')
            #  print(theObject@weights[i])
             # print('inp')
              #print(theObject@inputs[i])
              total <- total + ( theObject@weights[i] *  theObject@inputs[i])
              #print('Total')
             # print(total)
              if(is.na(total)==FALSE)
              {
              prevtotal <-total
              }
            }
            sigsum<-( 1.0/ (1.0  +exp(-total)))
            if(is.na(sigsum)==TRUE)
            {
              sigsum<-( 1.0/ (1.0  +exp(-prevtotal)))
            }
            if(is.na(sigsum)==TRUE)
            {
             # print('Error')
              sigsum<-prevtotal
            }
            if(is.na(sigsum)==TRUE)
            {
              sigsum <-1
            }
            #print('SigSum=')
           # print(sigsum)
            #sigsum<-sigmoid.output(total)
            #print(sigsum)
            theObject@output <- sigsum
            return(theObject@output)
          }
)
setGeneric(name="randomizeWeights",
           def=function(theObject,inputlength)
           {
             standardGeneric("randomizeWeights")
           }
)
setMethod(f="randomizeWeights",
          signature="Neuron",
          definition=function(theObject,inputlength)
          {
            #print(length(theObject@inputs))
            #print(class(theObject@inputs))
            #inplen<-length(theObject@inputs)
            #print(inplen)
            theObject@weights<-replicate(inputlength,0)
            
            for (i in 1:inputlength)
            {
              theObject@weights[i] <-   (i+1) * 0.001 # r.NextDouble();
            }
            #weights[1] = r.NextDouble();
            theObject@biasWeight<-  (i + 1) * 0.001 #r.NextDouble();
            return(theObject)
          }
)
setGeneric(name="adjustWeights",
           def=function(theObject,inputlength)
           {
             standardGeneric("adjustWeights")
           }
)
setMethod(f="adjustWeights",
          signature="Neuron",
          definition=function(theObject,inputlength)
          {
            
            #inplen<-length(theObject@inputs)
            #print(inplen)
            for (i in 1:inputlength)
            {
#cat (theObject@weights[i],':',  theObject@error ,':', theObject@inputs[i],'\n')              
              theObject@weights[i] <- theObject@weights[i] +  theObject@error * theObject@inputs[i]
              #print(theObject@weights[i])
            }
            #weights[1] = r.NextDouble();
            theObject@biasWeight<- theObject@biasWeight + theObject@error
            return(theObject)
          }
)
setGeneric(name="setInputs",
           def=function(theObject,inputspara,z)
           {
             standardGeneric("setInputs")
           }
)
setMethod(f="setInputs",
          signature="Neuron",
          definition=function(theObject,inputspara,z)
          {
            theObject@inputs[z] <-inputspara
            return(theObject)
          }
)
setGeneric(name="clearInput",
           def=function(theObject,inputlength)
           {
             standardGeneric("clearInput")
           }
)
setMethod(f="clearInput",
          signature="Neuron",
          definition=function(theObject,inputlength)
          {
            theObject@inputs <- replicate(inputlength,0)
            return(theObject)
          }
)
setGeneric(name="addInput",
           def=function(theObject,inputspara)
           {
             standardGeneric("addInput")
           }
)
setMethod(f="addInput",
          signature="Neuron",
          definition=function(theObject,inputspara)
          {
            theObject@inputs <- c(c(theObject@inputs),  inputspara)
            return(theObject)
          }
)
setGeneric(name="getOutputs",
           def=function(theObject)
           {
             standardGeneric("getOutputs")
           }
)
setMethod(f="getOutputs",
          signature="Neuron",
          definition=function(theObject)
          {
            
            lst<-theObject@output
            return(lst)
          }
)
setGeneric(name="getWeightByIndex",
           def=function(theObject,weightindex)
           {
             standardGeneric("getWeightByIndex")
           }
)
setMethod(f="getWeightByIndex",
          signature="Neuron",
          definition=function(theObject,weightindex)
          {
            
            lst<-theObject@weights[weightindex]
            return(lst)
          }
)
setGeneric(name="setErrors",
           def=function(theObject,inputspara)
           {
             standardGeneric("setErrors")
           }
)
setMethod(f="setErrors",
          signature="Neuron",
          definition=function(theObject,inputspara)
          {
            theObject@error <-inputspara
            return(theObject)
          }
)
setGeneric(name="setOutput",
           def=function(theObject,inputspara)
           {
             standardGeneric("setOutput")
           }
)
setMethod(f="setOutput",
          signature="Neuron",
          definition=function(theObject,inputspara)
          {
            theObject@output <-inputspara
            return(theObject)
          }
)
setGeneric(name="getErrors",
           def=function(theObject)
           {
             standardGeneric("getErrors")
           }
)
setMethod(f="getErrors",
          signature="Neuron",
          definition=function(theObject)
          {
            
            er<-theObject@error
            return(er)
          }
)
#Neuron class with methods created.....
#========================================================







library(stringr)
train<-function()
{
 
  
  totalsamples <-length(df$VectorEncoded[1:600])
  inputs<-vector("list",totalsamples)
  
  for(i in 1:totalsamples)
  {
    
    str1<- df$VectorEncoded[i]
    inputsingle  <-c()
    str1length<-nchar(str1)
    for(j in 1:str1length)
    {
      inputsingle <- c(c(inputsingle), as.numeric(substring( str1,j,j)))
    }
    inputsingle
    
    inputs[[i]]<- inputsingle
  }
  
  #=================================
   inputlength <- totalsamples
   colsize <- str1length
   #desired results
   mycates<-unlist(unique(df$Vulnerability.Type.s.))
   mycateslength<-length(mycates)
   singlesegment <- 1.0 /length(mycates)
   desiredresults<-c()
   count1<-0
   for(k in 1:totalsamples)
   {
     for(j1 in 1:mycateslength)
     {
      if (as.character(df$Vulnerability.Type.s.[k]) == mycates[j1])
       {
        desiredresults <- c(c(desiredresults) ,   (j1 * singlesegment))
        count1<-count1+1
      }
     }
   }
  # count1
   #unique(desiredresults)
  
   hiddenlayer1neuroncount <- 10
   hiddenlayer1Neurons <-c()
   for(i4 in 1:hiddenlayer1neuroncount)
   {
     nn<- Neuron()
     nn<-clearInput(nn, inputlength)
     nn<- randomizeWeights(nn , inputlength)
     hiddenlayer1Neurons<-c(c(hiddenlayer1Neurons),   nn)
   }
   
   outputlayerneuroncount <-1
   outputlayerNeurons<-c()
   for(i4 in 1:outputlayerneuroncount)
   {
     nn<-Neuron()
     nn<-clearInput(nn,  inputlength)
     nn<- randomizeWeights(nn,inputlength)
     outputlayerNeurons<- c( c(outputlayerNeurons) ,nn)
   }
   
 
   epoch <- 0
   epochidx<-1
   epochtotal<-1#10#100
   for(epochidx in 1:epochtotal)
   {
     
     
     for(i in 1:inputlength)
     {
     
      #  for(i4 in 1:hiddenlayer1neuroncount)
      #  {
          
          
           #hiddenlayer1Neurons[i4] <-  memalloc
        #}
       
       #   for (k1 in 1:colsize)
         # {
       
            for( i4 in 1 :hiddenlayer1neuroncount)
            {
              hiddenlayer1Neurons[[i4]] <- clearInput(hiddenlayer1Neurons[[i4]] ,inputlength)
              inplengthtmp <- length(inputs[[i]])
              for(z in 1:inplengthtmp)
              {
                hiddenlayer1Neurons[[i4]] <-setInputs(hiddenlayer1Neurons[[i4]],(inputs[[i]][z]),z)
              }
              #hiddenlayer1Neurons[i4] <-setInputs(hiddenlayer1Neurons[i4] ,(inputs[[i]][100]))
            }
          #}#end for k1
          
        
           for( i4 in 1: outputlayerneuroncount)
           {
             
      
             #tmp1<-c()
             outputlayerNeurons[[i4]] <- clearInput(outputlayerNeurons[[i4]] ,inputlength)
             for(i5 in 1: hiddenlayer1neuroncount)
             {
    
               #slot(hiddenlayer1Neurons[[i5]], "output")
               #hiddenlayer1Neurons[[1]]
              outputtmp<- myOutput(hiddenlayer1Neurons[[i5]])
              hiddenlayer1Neurons[[i5]]<- setOutput(hiddenlayer1Neurons[[i5]],outputtmp)
              for(z in 1:inplengthtmp)
              {
                outputlayerNeurons[[i4]] <-setInputs(outputlayerNeurons[[i4]],outputtmp,z)
              }
              
             }
             #.....outputlayerNeurons[i4] <- setInputs(outputlayerNeurons[i4], tmp1)
           }
       
       
        if(epochidx >=1)
        {
      #  print(inputs[i])
          outputtmp<- myOutput(outputlayerNeurons[[1]])
         # print(outputtmp)
        }
       
       
      # 2) back propagation (adjusts weights)
      # adjusts the weight of the output neuron, based on its error
        for(i6 in 1:outputlayerneuroncount)
        {
          res <- 1
          for(i8 in 1:1)
          {
            
            outputtmp <- myOutput(outputlayerNeurons[[i6]])  #getOutputs(outputlayerNeurons[[i6])
            outputlayerNeurons[[i6]]<- setOutput(outputlayerNeurons[[i6]],outputtmp)
            #res = res * (desiredresults[i, i8] - outputtmp)
            res <- res * (desiredresults[i] - outputtmp)
          }
          
            #sigmoidderivative 
            errortmp <- outputtmp * (1 - outputtmp)
          outputlayerNeurons[[i6]] <- setErrors(outputlayerNeurons[[i6]] , errortmp * res)
          outputlayerNeurons[[i6]] <- adjustWeights(outputlayerNeurons[[i6]],inputlength)
          #print('Output')
          #print(outputlayerNeurons[[i6]])
          #print('---------------------')
          myOutput(outputlayerNeurons[[i6]])
        }#end for i6
       
      #then adjusts the hidden neurons' weights, based on their errors
       for(i6 in 1:hiddenlayer1neuroncount)
       {
         
         errortmp<-1
         for(i7 in 1:outputlayerneuroncount)
         {
           
           error1 <- getErrors( outputlayerNeurons[[i7]])
           weightindex<-i6
          weight <- getWeightByIndex(outputlayerNeurons[[i7]],weightindex)
           errortmp <- errortmp *  error1 *   weight
        # print(errortmp)
         }
         outputtmp <- myOutput(hiddenlayer1Neurons[[i6]])
         hiddenlayer1Neurons[[i6]]<- setOutput(hiddenlayer1Neurons[[i6]],outputtmp)
         outputtmp<- outputtmp * (1-outputtmp)
         hiddenlayer1Neurons[[i6]] <- setErrors(hiddenlayer1Neurons[[i6]] ,outputtmp*errortmp)
       }
       for(i6 in 1:hiddenlayer1neuroncount)
       {
         
         hiddenlayer1Neurons[[i6]]  
         hiddenlayer1Neurons[[i6]] <-adjustWeights(hiddenlayer1Neurons[[i6]],inputlength)
       }
       
     }#  end for(i in 1:inputlength)
     
     print(epochidx)  
    print( outputlayerNeurons)
   } #end for epochidx

}#end train function

train()
outputlayerNeurons[[1]]


vs<-'Nelson Open Source ERP v6.3.1 allows SQL Injection via the db/utils/query/data.xml query parameter.
500 Levels: Absolute path traversal vulnerability in kgb 1.0b4 allows remote attackers to write to arbitrary files via a full pathname in a crafted archive'
testrecord<-df[100,4] 
  vs<-testrecord #'Description']  
  cnninputvector<-''
  for(j in 1:UniqueWordsCount )
  {
    
    if( grepl (UniqueWords[j] ,vs))
    {
      cnninputvector <- paste(cnninputvector,'1',sep='')
    }else
    {
      cnninputvector <- paste(cnninputvector,'0',sep='')
    }
  }
#  df[i,'VectorEncoded']<-cnninputvector
dfrows<-nrow(df)
for(i in 1:dfrows)
{
  if( df$VectorEncoded[i] == cnninputvector)
  {
    
    cat(df$VectorEncoded[i])
    print(df[i,3])
  }
}
#-------------------MAX SIMILARITY
st2 <-cnninputvector
st2len<-nchar(st2)
counts<-c()
maxmatchingindex<-0
maxval<-0
maxmatchingcount<-0
for(i in 1:dfrows)
{
  st1 <- df$VectorEncoded[i] 
  counttmp<-0
  st1len<-nchar(st1)
  
  maxval<- 0
  if(st1len>st2len)
  {
    maxval<-st1len
  }else
  {
    maxval<-st2len
  }
  for(j in 1:maxval)
  {
    if( substr(st1,j,j) ==substr(st2,j,j) )
    {
      counttmp<-counttmp+1
    }
  }
  counts<-c(counts,counttmp)
  if(counttmp>maxmatchingcount)
  {
  
    maxmatchingindex<-i
    maxmatchingcount<-counttmp
    print(maxmatchingcount)
    
  }
  counttmp<-0
}
cat('Matching Record:\n')
print(maxmatchingindex)
cat('Matching Words:\n')
print(maxmatchingcount)
cat('Result Category:\n')
print(df$Vulnerability.Type.s.[maxmatchingindex])



